<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="SPL File RemoteDirScanAndGet.spl"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_compilationunit"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>SPL File RemoteDirScanAndGet.spl</title>
</head>
<body id="spldoc_compilationunit">


<h1 class="title topictitle1">SPL File <tt class="ph tt">RemoteDirScanAndGet.spl</tt></h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">IBMStreams com.ibm.streamsx.inet Samples</a> &gt; <a class="xref" href="tk$FTP RemoteDirScanAndGet sample.html">FTP RemoteDirScanAndGet sample 1.0.1</a> &gt; <a class="xref" href="ns$com.ibm.streamsx.inet.ftp.sample.html">com.ibm.streamsx.inet.ftp.sample</a> &gt; RemoteDirScanAndGet.spl</p>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Content</h2>
  
  <dl class="dl">
    <dt class="dt dlterm"/>
<dd class="dd"/>

    
      <dt class="dt dlterm splhead-2">Operators</dt>

      <dd class="dd">
<ul class="sl simple">
<li class="sli"><strong class="ph b"><a class="xref" href="spl$com.ibm.streamsx.inet.ftp.sample$RemoteDirScanAndGet.html#spldoc_compilationunit__composite_operator__RemoteDirScanAndGet">RemoteDirScanAndGet</a></strong>: This sample demonstrates the usage of the telco FTP toolkit.
</li>

</ul>

      </dd>

    
  </dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Composites</h2>
  
</div>

<div class="section" id="spldoc_compilationunit__composite_operator__RemoteDirScanAndGet"><h2 class="title sectiontitle splpart">composite RemoteDirScanAndGet</h2>
  
</div>

<div class="section splgraph">
  <embed class="image" src="../../image/tk$FTP RemoteDirScanAndGet sample/op$com.ibm.streamsx.inet.ftp.sample$RemoteDirScanAndGet.svg" width="640" height="291"/>
</div>

<div class="section">

<p class="p">This sample demonstrates the usage of the telco FTP toolkit. This sample uses the FTPReader operator and the FTPCommand operator. It scans a remote directory and initiates file transfers for the found files. Finally the transferred files are moved into an archive directory at the remote host. The sample initiates a text file transfer for files with names *.txt  and the sample initiates a binary file transfer for files with names *.bin. The results a printed to stdout and in separate output text files. 
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Parameters</h2>

<ul class="sl simple">
<li class="sli"><strong class="ph b">protocol</strong>: the transmission protocol
</li>

<li class="sli"><strong class="ph b">host</strong>: the remote host name or IP address
</li>

<li class="sli"><strong class="ph b">path</strong>: the remote path to a directory which stores some files to be transferred  files with the extension .txt are handled as text files and files with extension .bin are transferred as binary files. In case of sftp protocol  the path should be an absolute path. In all other cases the path depends on the server configuration.
</li>

<li class="sli"><strong class="ph b">username</strong>: the remote user
</li>

<li class="sli"><strong class="ph b">password</strong>: the password
</li>

<li class="sli"><strong class="ph b">verbosityDirScan</strong>: the verbosity for the directory scan operator
</li>

<li class="sli"><strong class="ph b">verbosityTxtFile</strong>: the verbosity for the text file transfer operator
</li>

<li class="sli"><strong class="ph b">verbosityBinFile</strong>: the verbosity for the binary file transfer operator
</li>

<li class="sli"><strong class="ph b">verbosityCommand</strong>: the verbosity for the command execution operator
</li>

</ul>

</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section"><h2 class="title sectiontitle splhead-2">SPL Source Code</h2>
  
</div>


<div class="section">
   <pre class="pre codeblock">

 public composite RemoteDirScanAndGet {
 	param
 		expression&lt;Protocol&gt; $protocol : (Protocol)getSubmissionTimeValue("protocol", "ftp");
 		expression&lt;rstring&gt; $host : getSubmissionTimeValue("host", "localhost");
 		expression&lt;rstring&gt; $path : getSubmissionTimeValue("path", "/ftptry/");
 		expression&lt;rstring&gt; $username : getSubmissionTimeValue("username", "username");
 		expression&lt;rstring&gt; $password : getSubmissionTimeValue("password", "Test!pass");
 		expression&lt;boolean&gt; $verbosityDirScan : (boolean)getSubmissionTimeValue("verbosityDirScan", "false");
 		expression&lt;boolean&gt; $verbosityTxtFile : (boolean)getSubmissionTimeValue("verbosityTxtFile", "false");
 		expression&lt;boolean&gt; $verbosityBinFile : (boolean)getSubmissionTimeValue("verbosityBinFile", "false");
 		expression&lt;boolean&gt; $verbosityCommand : (boolean)getSubmissionTimeValue("verbosityCommand", "false");
 		
 	graph
 	
 	//provide a trigger stream for the ftp directory scan
 	stream&lt;int32 count&gt; TriggerStream = Beacon() {
 		param
 			initDelay : 2.0;
 			iterations : 2;
 			period : 10.0;
 		output TriggerStream : count = (int32)IterationCount();
 		config placement : partitionColocation("DIR");
 	}
 	//scan the remote directory
 	(
 		stream&lt;rstring fileName, uint64 size, rstring date, rstring user, boolean isFile, uint32 transferCount, uint32 failureCount, uint64 bytesTransferred&gt; FilenameStream as OUT;
 		//stream&lt;rstring error&gt; ErrorStream
 		stream&lt;rstring errorText, int32 error, uint32 transferCount, uint32 failureCount, uint64 bytesTransferred&gt; ErrorStream as ERR
 	) = FTPReader(TriggerStream) {
 		param
 			protocol : $protocol;
 			isDirReader : true;
 			host : $host;
 			path : $path;
 			username : $username;
 			password : $password;
 			useEPSV : false;
 			curlVerbose : $verbosityDirScan;
 		output
 			OUT :
 				fileName = FileName(),
 				size = FileSize(),
 				date = FileDate(),
 				user = FileUser(),
 				isFile = IsFile(),
 				//transferCount = NoTransfers(),
 				transferCount = TransferCount(),
 				//failureCount =  NoTransferFailures(),
 				failureCount = TransferFailureCount(),
 				//bytesTransferred = NoBytesTransferred();
 				bytesTransferred = BytesTransferred();
 			ERR:
 				errorText = ErrorText(),
 				//error = Error(),
 				error = ErrorCode(),
 				//transferCount = NoTransfers(),
 				transferCount = TransferCount(),
 				//failureCount =  NoTransferFailures(),
 				failureCount =  TransferFailureCount(),
 				//bytesTransferred = NoBytesTransferred();
 				bytesTransferred = BytesTransferred();
 		config placement : partitionColocation("DIR");
 	}
 	//print the results
 	() as DirTap = ResultSink(FilenameStream) {
 		param
 			file : "Dir.txt";
 			loc : "DIRTAP";
 	}
 	() as ErrorTap = ResultSink(ErrorStream) {
 		param
 			file : "DirError.txt";
 			loc : "DIRTAP";
 	}
 	
 	//split in text and binary files
 	stream&lt;FilenameStream&gt; FilenameStream2 = Filter(FilenameStream as IN) {
 		param filter : IN.isFile &amp;&amp; (spl.collection::size(regexMatch(IN.fileName, ".*txt")) &gt; 0);
 		config placement : partitionColocation("DIR");
 	}
 	stream&lt;FilenameStream&gt; FilenameStream3 = Filter(FilenameStream as IN) {
 		param filter : IN.isFile &amp;&amp; (spl.collection::size(regexMatch(IN.fileName, ".*bin")) &gt; 0);
 		config placement : partitionColocation("DIR");
 	}
 
 	//get the text files
 	stream&lt;rstring line, int32 sequence, rstring file, rstring url&gt; FileStream as OUT = FTPReader(FilenameStream2 as IN) {
 		param
 			protocol : $protocol;
 			isDirReader : false;
 			host : $host;
 			path : $path;
 			filename : IN.fileName;
 			username : $username;
 			password : $password;
 			connectionCloseMode : punct;
 			curlVerbose : $verbosityTxtFile;
 		output OUT :
 			line = Line(),
 			sequence = Sequence(),
 			file = IN.fileName,
 			url = Url();
 		config placement : partitionColocation("TEXT");
 	}
 	//print the results
 	() as TextTap = ResultSink(FileStream) {
 		param
 			file : "DataText.txt";
 			loc : "TEXTTAP";
 	}
 	
 	//prepare the command
 	stream&lt;rstring fileName&gt; Sink = Custom (FileStream as IN) {
 		logic state : mutable rstring theFile = "";
 			onTuple IN : theFile = file;
 			onPunct IN : {
 				if (theFile != "") {
 					submit({fileName=theFile}, Sink);
 					theFile = "";
 				}
 			}
 		config placement : partitionColocation("TEXT");
 	}
 	//get bin files
 	stream&lt;blob content, int32 sequence, rstring file, rstring url&gt; BinFileStream as OUT = FTPReader(FilenameStream3 as IN) {
 		param
 			protocol : $protocol;
 			host : $host;
 			path : $path;
 			filename : IN.fileName;
 			username : $username;
 			password : $password;
 			connectionCloseMode : ever;
 			curlVerbose : $verbosityBinFile;
 		output OUT :
 			content = Binary(),
 			sequence = Sequence(),
 			file = IN.fileName,
 			url = Url();
 		config placement : partitionColocation("BIN");
 	}
 	//print the results
 	() as BinTap = ResultSink(BinFileStream) {
 		param
 			file : "DataBin.txt";
 			loc : "BINTAP";
 	}
 	//prepare the command
 	stream&lt;rstring fileName&gt; Sink2= Custom (BinFileStream as IN) {
 		logic state : mutable rstring theFile = "";
 			onTuple IN : theFile = file;
 			onPunct IN : {
 				if (theFile != "") {
 					submit({fileName=theFile}, Sink2);
 					theFile = "";
 				}
 			}
 		config placement : partitionColocation("BIN");
 	}
 	
 	//prepare command stream
 	stream&lt;rstring command, rstring file, rstring file2&gt; CommandStream as OUT = Custom(Sink, Sink2 as IN) {
 		logic state : mutable boolean first = true;
 		onTuple IN : {
 			if (first) {
 				submit({command="pwd", file="", file2=""}, OUT);
 				submit({command="mkdir", file= "archive", file2=""}, OUT);
 				first = false;
 			}
 			submit({command="rename", file= fileName, file2= "archive/" + fileName}, OUT);
 		}
 		config placement : partitionColocation("MOVE");
 	}
 	//move the file into archive directory
 	(
 		stream&lt;boolean success, rstring command, rstring fileName, rstring file2, uint32 transferCount, uint32 failureCount&gt; ResultStream as OUT;
 		//stream&lt;rstring error&gt; ResultErrorStream
 		stream&lt;rstring errorText, int32 error, uint32 transferCount, uint32 failureCount&gt; ResultErrorStream as ERR
 	) = FTPCommand(CommandStream as IN) {
 		param
 			protocol : $protocol;
 			host : $host;
 			path : $path;
 			filename : IN.file;
 			filenameTo : IN.file2;
 			command : IN.command;
 			username : $username;
 			password : $password;
 			connectionCloseMode : never;
 			curlVerbose : $verbosityCommand;
 		output
 			OUT :
 				fileName = IN.file,
 				success = Success(),
 				//transferCount = NoCommands(),
 				transferCount = CommandCount(),
 				//failureCount =  NoFailures();
 				failureCount =  CommandFailureCount();
 			ERR :
 				errorText = ErrorText(),
 				//error = Error(),
 				error = ErrorCode(),
 				//transferCount = NoTransfers(),
 				transferCount = CommandCount(),
 				//failureCount =  NoTransferFailures();
 				failureCount = CommandFailureCount();
 		config placement : partitionColocation("MOVE");
 	}
 	//print out the command and the time
 	() as CommandTap= ResultSink(CommandStream) {
 		param
 			file : "Command.txt";
 			loc : "MOVETAP1";
 	}
 	//print out the results and the time
 	() as ResultTap= ResultSink(ResultStream) {
 		param
 			file : "CommandResult.txt";
 			loc : "MOVETAP2";
 	}
 	() as ResultErrorTap= ResultSink(ResultErrorStream) {
 		param
 			file : "CommandError.txt";
 			loc : "MOVETAP2";
 	}
 }

   </pre>

</div>

</div>


</body>
</html>