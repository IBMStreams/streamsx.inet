use com.ibm.streamsx.inet.http::*;

/**
 * This main composite invokes the HTTPRequestAsyncComposite cyclcal
 * 
 * @param	url		The url to get
 */
public composite Main {
	param
		expression<rstring> $url :                     getSubmissionTimeValue("url", "http://httpbin.org/get");

	graph
		//provide a trigger stream for the ftp directory scan
		stream<rstring url, rstring someText> Trigger as O = Beacon() {
			param period: 1.0;
			output
				O:
					url = $url,
					someText = "This is sequence number: " + (rstring)IterationCount();
		}

		//Invocation of the async composite
		(
			stream<I, tuple<rstring body, list<rstring> headers, rstring message, int32 status>> HttpStream as H;
			stream<rstring url, rstring message, int32 status> ErrorStream as E
		) = HTTPRequestAsyncComposite(Trigger as I) {
			param
				method : "get";
				url : url;
		}

		//Result printer
		() as ResultSink = Custom(HttpStream as I) {
			logic
				onTuple I: {
					printStringLn("*** url ***");
					printStringLn(url);
					printStringLn("*** someText ***");
					printStringLn(someText);
					printStringLn("*** headers ***");
					println(headers);
					printStringLn("*** status ***");
					println(status);
					printStringLn("*** message ***");
					printStringLn(message);
					printStringLn("*** body ***");
					printStringLn(body);
				}
				onPunct I : println(currentPunct());
		}

		//Error printer
		() as ErrorSink = Custom(ErrorStream as I) {
			logic
				onTuple I: println(I);
				onPunct I : println(currentPunct());
		}

}

/**
 * The operator HTTPRequestAsyncComposite implements asynchron http operations

 * @input	Request				The request Stream
 * @output	Result				The result stream. One tuple is generated if the operation succeeds.
 * @output	Error				The error stream. One tuple indicates a failed http operation.
 * 
 * @param	url					The request url. Required
 * @param	data 				The body of the operation. Default is ""
 * @param	headers 			http headers. Default is the empty list
 * @param	contentTypeHeader	The content type header. Default is "ContentType: application/x-www-form-urlencoded"
 * @param	method				The method of the request value must be get, put, push or delete. Required
 * @param	requestTimeout		This is the maximum time in seconds that you allow the transfer operation to take. Normally, name lookups can take a considerable time and limiting operations to less than a few minutes risk aborting perfectly normal operations. Default timeout is 5
 * @param	connectionTimeout	This is the maximum time in seconds that you allow the connection to the server to take. This only limits the connection phase, once it has connected, this option is of no more use. Default is 20 seconds
 * @param	width_				The number of parallel threads to use. Default is 6
 * 
 */
public composite HTTPRequestAsyncComposite (output Result, Error; input Request) {
	param
		attribute $url;
		
		expression<rstring> $data : "";
		expression<list<rstring>> $headers : [];
		expression<rstring> $contentTypeHeader: "ContentType: application/x-www-form-urlencoded";
		expression<rstring> $method : "get";
		expression<int32> $requestTimeout : 5;
		expression<int32> $connectionTimeout : 120;
		expression<int32> $width_: 6;
	graph
		/*stream<I, tuple<rstring url>> MergedAttributes as O = Custom(Request as I) {
			logic
				onTuple I : {
					mutable tuple<O> ot = {};
					assignFrom(ot, I);
					ot.url = $url;
					submit(ot, O);
				}
				onPunct I : submit(currentPunct(), O);
		}*/
		
		@parallel(width=$width_)
		(
			stream<I, tuple<rstring body, list<rstring> headers, rstring message, int32 status, rstring url>> Result as R;
			stream<rstring url, rstring message, int32 status> Error as E
		) = Custom(Request as I) {
			logic
				onTuple I: {
					mutable int32 error =0;
					mutable list<rstring> replyHeaders = [];
					mutable list<rstring> requestHeaders = $headers;
					appendM(requestHeaders, $contentTypeHeader);
					mutable rstring result_ = "";
					mutable boolean request_ = true;
					if ($method == "get") {
						result_ = httpGet($url, requestHeaders, "" ,"", replyHeaders, error, 5, 0);
					} else if ($method == "post") {
						result_ = httpPost($data, $url, requestHeaders, "" ,"", replyHeaders, error, 5, 0);
					} else if ($method == "put") {
						result_ = httpPut($data, $url, requestHeaders, "" ,"", replyHeaders, error, 5, 0);
					} else if ($method == "delete") {
						result_ = httpDelete($url, requestHeaders, "" ,"", error, 5, 0);
					} else {
						appTrc(Trace.error,"Invalid method used "+$method+"Request is ignored");
						request_ = false;
						submit({url="", message="Invalid method used "+$method+"Request is ignored", status=error}, E);
					}
					if (error != 0) {
						appTrc(Trace.error,"Error code on get was "+(rstring)error);
						submit({url="", message="error=", status=error}, E);
					} else {
						if (request_ ) {
							mutable tuple<R> ot = {};
							assignFrom(ot, I);
							ot.body=result_; ot.headers=replyHeaders; ot.message="success"; ot.status=error;
							submit(ot, R);
						}
					}
				}
				onPunct I : submit(currentPunct(), R);
			config
				threadedPort : queue(I, Sys.DropLast, 1);
		}
}