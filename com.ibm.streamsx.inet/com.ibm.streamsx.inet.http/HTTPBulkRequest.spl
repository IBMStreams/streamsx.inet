namespace com.ibm.streamsx.inet.http;

/**
 * The operator HTTPBulkRequest implements http bulk operations and processes the results asynchronous from the input stream.
 * The operator opens on request up to *maxConnections*parallel http connections an sends the results downstream once the 
 * response is received.

 * @input	Request				The request Stream with attributes of the http request
 * @output	Result				The result stream. One tuple is generated for each input tuple.
 * 								The minimum type is : tuple<rstring body, list<rstring> headers, rstring message, int32 status, rstring url> where
 * 								body is the response body, headers is the response header list, message is the error/success message, status is the error status of the operation, url is the encoded url
 * @output	Error				The error stream. One tuple indicates a failed http operation.
 * 								The type is : <rstring url, rstring message, int32 status>.
 * 
 * @param	method				This required parameter determines the kind of the http request. Type HttpMethod
 * @param	url					The request url. Required parameter.
 * @param	urlEncode			Defines the function to be used to prepare the url. Useful values are *passThrough* or [function:com.ibm.streamsx.inet.http::urlEncode(rstring)] . Default is urlEncode.
 * @param	data				The body of the operation. Default is the empty string.
 * @param	headers				http headers passes in the http request. Default is the empty list.
 * @param	contentTypeHeader	The content type header. If this header is not empty, it is appended to the headers list. Default is "ContentType: application/x-www-form-urlencoded"
 * @param	requestTimeout		This is the maximum time in seconds that you allow the transfer operation to take. Normally, name lookups can take a considerable time and limiting operations to less than a few minutes risk aborting perfectly normal operations. Default timeout is 5
 * @param	connectionTimeout	This is the maximum time in seconds that you allow the connection to the server to take. This only limits the connection phase, once it has connected, this option is of no more use. Default is 20 seconds
 * @param	width				The number of parallel used threads. This conforms to the maximum number if used http connections. Default is 8
 * @param	queue				The length of the input queue ot each thread. Default 1
 * @param	congestionPolicy	The congestion policy of the input queue. Type *Sys.CongestionPolicy*. Default Sys.Wait
 * @param	user				If this string is not empty, this user name is passed to to the server.
 * @param	password			If this string is not empty, this password is passed to the server
 * @param	certFile			If this string is not empty, this is the absolute path to a certificate file sent to the server
 * @param	certType			If this string is not empty, this is the cert file type (PEM, P12)
 * @param	keyFile				If this string is not empty, this is the absolute path to a private key file to be sent to the server
 * @param	keyType				If this string is not empty, this is the key file type (PEM, P12)
 * @param	keyPass				If this string is not empty, this is the password for the private key
 */
public composite HTTPBulkRequest (output Result, Error; input Request) {
	param
		expression<HttpMethod>    $method;
		attribute                 $url;
		function                  $urlEncode : urlEncode;
		expression<rstring>       $data : "";
		expression<list<rstring>> $headers : [];
		expression<rstring>       $contentTypeHeader: "ContentType: application/x-www-form-urlencoded";
		expression<int32>         $requestTimeout : 5;
		expression<int32>         $connectionTimeout : 120;
		expression<int32>         $width: 8;
		expression<int32>         $queue : 1;
		expression<Sys.CongestionPolicy> $congestionPolicy : Sys.Wait;
		expression<rstring>       $user : "";
		expression<rstring>       $password : "";
		expression<rstring>       $certFile : "";
		expression<rstring>       $certType : "";
		expression<rstring>       $keyFile : "";
		expression<rstring>       $keyType : "";
		expression<rstring>       $keyPass : "";

	type
		/**
		 * This type determines the kind of the http operation
		 * values are httpGet, httpPut, httpPost, httpDelete
		 */
		static HttpMethod = enum {httpGet, httpPut, httpPost, httpDelete};

	graph
		@parallel(width=$width)
		(
			stream<I, tuple<rstring body, list<rstring> headers, rstring message, int32 status, rstring url>> Result as R;
			stream<rstring url, rstring message, int32 status> Error as E
		) = Custom(Request as I) {
			logic
				onTuple I: {
					mutable int32 error_ =0;
					mutable list<rstring> replyHeaders_ = [];
					mutable list<rstring> requestHeaders_ = $headers;
					if (length($contentTypeHeader) > 0) {
						appendM(requestHeaders_, $contentTypeHeader);
					}
					rstring urlProcessed_ = $urlEncode($url);
					mutable rstring result_ = "";
					appTrc(Trace.trace, "Emit http request "+
									(rstring)$method+
									" url:"+urlProcessed_+
									" requestHeaders:"+(rstring)requestHeaders_+
									" user:"+$user+
									" password:*****"+
									" certFile:"+$certFile+
									" certType:"+$certType+
									" keyFile:"+$keyFile+
									" keyType:"+$keyType+
									" keyPass:"+$keyPass+
									" requestTimeout:"+(rstring)$requestTimeout+
									" connectionTimeout:"+(rstring)$connectionTimeout);
					if ($method == HttpMethod.httpGet) {
						result_ = com.ibm.streamsx.inet.http::httpGet   (       urlProcessed_, requestHeaders_, $user, $password, $certFile, $certType, $keyFile, $keyType, $keyPass, replyHeaders_, error_, $requestTimeout, $connectionTimeout);
					} else if ($method == HttpMethod.httpPost) {
						result_ = com.ibm.streamsx.inet.http::httpPost  ($data, urlProcessed_, requestHeaders_, $user, $password, $certFile, $certType, $keyFile, $keyType, $keyPass, replyHeaders_, error_, $requestTimeout, $connectionTimeout);
					} else if ($method == HttpMethod.httpPut) {
						result_ = com.ibm.streamsx.inet.http::httpPut   ($data, urlProcessed_, requestHeaders_, $user, $password, $certFile, $certType, $keyFile, $keyType, $keyPass, replyHeaders_, error_, $requestTimeout, $connectionTimeout);
					} else if ($method == HttpMethod.httpDelete) {
						result_ = com.ibm.streamsx.inet.http::httpDelete(       urlProcessed_, requestHeaders_, $user, $password, $certFile, $certType, $keyFile, $keyType, $keyPass,                error_, $requestTimeout, $connectionTimeout);
					}
					mutable rstring mess_="success";
					if (error_ != 0) {
						mess_="error";
						appTrc(Trace.error,"Error code in method "+(rstring)$method+" url:"+urlProcessed_+" was "+(rstring)error_);
						submit({url=urlProcessed_, message=mess_, status=error_}, E);
					}
					mutable tuple<R> ot = {};
					assignFrom(ot, I);
					ot.body=result_; ot.headers=replyHeaders_; ot.message=mess_; ot.status=error_;
					submit(ot, R);
				}
				onPunct I : {
					submit(currentPunct(), R);
					submit(currentPunct(), E);
				}
			config
				threadedPort : queue(I, $congestionPolicy, $queue);
		}
}

/**
 * This function passes the input string transparently
 * @param	val the input string
 * @return	the unchanged input string
 */
public rstring passThrough(rstring val) { return val; }
